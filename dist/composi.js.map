{"version":3,"file":"composi.js","sources":["../lib/patch.js","../lib/mixin.js","../lib/component.js","../lib/render.js","../lib/h.js"],"sourcesContent":["/**\n * A function to merge two objects together. The properties of the second object will overwrite any matching properties in the first object.\n * @param {Object} obj1 The first object to merge.\n * @param {Object} obj2 The second object to merge.\n */\nfunction mixin(obj1, obj2) {\n  const result = {}\n  for (let i in obj1) {\n    result[i] = obj1[i]\n  }\n  for (let i in obj2) {\n    result[i] = obj2[i]\n  }\n  return result\n}\n\n/**\n * @constructor \n * @param {node} oldNode Original node or null.\n * @param {node} newNode New node.\n * @param {node} element The component root element.\n * @param {node} container The container element in which component is rendered.\n */\nexport function patch(oldNode, newNode, element, container) {\n  return diffAndPatch(container || document.body, element, oldNode, newNode)\n}\n\n/**\n * Patch functions:\n * setProps \n * createNode\n * createElement\n * getKey\n * updateElement\n * removeElement\n * diffAndPatch\n */\n\n/**\n * Function to set properties and attributes on element.\n * @param {node} element \n * @param {string} name \n * @param {string|number|boolean} value \n * @param {string|number|boolean} oldValue \n */\nfunction setProps(element, name, value, oldValue) {\n  if (name === 'key') {\n  } else if (name === 'style' && typeof value !== 'string') {\n    for (let name in mixin(oldValue, (value = value || {}))) {\n      element.style[name] = value[name] + \"\" || ''\n    }\n  } else {\n    if (value === 0) value = value + \"\"\n    // Handle cases where 'className' is used:\n    if (name === 'className') name = 'class'\n    if (/^on.*$/.test(name)) name = name.toLowerCase()\n    // Cannot set SVG properties this way, so test:\n    if (element.namespaceURI !== 'http://www.w3.org/2000/svg') element[name] = value\n\n    // In case of inline events, value would be function.\n    // This avoids resetting them if they were set above as a property.\n    if (typeof value !== 'function') {\n      if (!!value) {\n        // Support SVG 'xlink:href' property:\n        if (name === 'xlink-href') {\n          element.setAttributeNS('http://www.w3.org/1999/xlink', 'href', value)\n          element.setAttribute('href', value)\n        } else {\n          element.setAttribute(name, value)\n        }\n      } else {\n        element.removeAttribute(name)\n      }\n    }\n  }\n}\n\n/**\n * Function to create an HTML or SVG node.\n * @param {node} node node A node to create.\n * @param {svg} svg Whether the node is SVG or not.\n */\nfunction createNode(node, svg) {\n  const element = (svg = svg || node.type === \"svg\")\n  ? document.createElementNS(\"http://www.w3.org/2000/svg\", node.type)\n  : document.createElement(node.type)\n\n  Object.keys(node.props).forEach(key => setProps(element, key, node.props[key]))\n  node.children.map(child => element.appendChild(createElement(child, svg)))\n  return element\n}\n\n/**\n * Function to convert hyperscript/JSX into DOM nodes.\n * @param {jsx|hyperscript} node A node to create.\n * @param {svg} svg Whether the node is SVG or not.\n */\nfunction createElement(node, svg) {\n  return typeof node === \"string\" ? document.createTextNode(node) : createNode(node, svg)\n}\n\n/**\n * Function to get a node's key.\n * @param {node} node \n */\nfunction getKey(node) {\n  if (node && node.props) {\n    return node.props.key\n  }\n}\n\n/**\n * Update an element with new values for properties and/or children.\n * @param {Element} element \n * @param {node} oldProps \n * @param {object} props \n */\nfunction updateElement(element, oldProps, props) {\n  Object.keys(mixin(oldProps, props)).forEach(key => {\n    let value = props[key]\n    let oldValue = key === \"value\" || key === \"checked\" ? element[key] : oldProps[key]\n\n    if (value !== oldValue) setProps(element, key, value, oldValue)\n  })\n}\n\n/**\n * Function to remove element from DOM.\n * @param {node} container The container of the element to remove.\n * @param {node} element The element to remove.\n */\nconst removeElement = (container, element) => container.removeChild(element)\n\n/**\n * Function to patch DOM. Diffs virtual nodes, then patches the DOM.\n * @param {node} container \n * @param {node} element \n * @param {node} oldNode \n * @param {node} newNode \n * @param {boolean} svg \n * @param {node} nextSibling \n */\nfunction diffAndPatch(container, element, oldNode, newNode, svg, nextSibling) {\n  // There is no oldNode, so this is first render.\n  if (oldNode == null) {\n    element = container.insertBefore(createElement(newNode, svg), element)\n  // There's an oldNode, so patch.\n  } else if (newNode.type != null && newNode.type === oldNode.type) {\n    updateElement(element, oldNode.props, newNode.props)\n\n    svg = svg || newNode.type === \"svg\"\n    const len = newNode.children.length\n    let oldLen = oldNode.children.length\n    let oldKeyed = {}\n    let oldElements = []\n    let keyed = {}\n\n    let k = 0\n    while (k < oldLen) {\n      let oldElement = (oldElements[k] = element.childNodes[k])\n      let oldChild = oldNode.children[k]\n      let oldKey = getKey(oldChild)\n      if (null != oldKey) oldKeyed[oldKey] = [oldElement, oldChild]\n      k++\n    }\n\n    let i = 0, j = 0\n    while (j < len) {\n      let oldElement = oldElements[i]\n      let oldChild = oldNode.children[i]\n      let newChild = newNode.children[j]\n      let oldKey = getKey(oldChild)\n      if (keyed[oldKey]) {\n        i++\n        continue\n      }\n      \n      let newKey = getKey(newChild)\n      let keyedNode = oldKeyed[newKey] || []\n      if (null == newKey) {\n        if (null == oldKey) {\n          diffAndPatch(element, oldElement, oldChild, newChild, svg)\n          j++\n        }\n        i++\n      } else {\n        oldKey === newKey ? diffAndPatch(element, keyedNode[0], keyedNode[1], newChild, svg) && i++ :\n        keyedNode[0] ? element.insertBefore(keyedNode[0], oldElement) && diffAndPatch(element, keyedNode[0], keyedNode[1], newChild, svg) : diffAndPatch(element, oldElement, null, newChild, svg)\n        \n        keyed[newKey] = newChild\n        j++\n      }\n    }\n\n    while (i < oldLen) {\n      let oldChild = oldNode.children[i]\n      let oldKey = getKey(oldChild)\n      if (null == oldKey) removeElement(element, oldElements[i])\n      i++\n    }\n\n    Object.keys(oldKeyed).forEach(key => {\n      let keyedNode = oldKeyed[key]\n      let reusableNode = keyedNode[1]\n      if (!keyed[reusableNode.props.key]) {\n        removeElement(element, keyedNode[0])\n      }\n    })\n  } else if (element && newNode !== element.nodeValue) {\n    if (typeof newNode === \"string\" && typeof oldNode === \"string\") {\n      element.nodeValue = newNode\n    } else {\n      element = container.insertBefore(\n        createElement(newNode, svg),\n        (nextSibling = element)\n      )\n      removeElement(container, nextSibling, oldNode.data)\n    }\n  }\n  return element\n}\n","/**\n * A mixin function used for updating component state.\n * @param {object} obj1 An object as the target.\n * @param {object} obj2 An object of properties to target.\n */\nexport const mixin = (obj1, obj2) => {\n  Object.keys(obj2).forEach(p => {\n    if (obj2.hasOwnProperty(p)) {\n      Object.defineProperty(obj1, p, {\n        value: obj2[p],\n        writable: true,\n        enumerable: false,\n        configurable: true\n      })\n    }\n  })\n}\n","import {h} from './h'\nimport {patch} from './patch'\nimport {mixin} from './mixin'\n\nvar rAF = window.requestAnimationFrame\n  || window.webkitRequestAnimationFrame\n  || window.mozRequestAnimationFrame\n  || window.msRequestAnimationFrame\n  || function(cb) { return setTimeout(cb, 16) }\n\n/**\n * @type {object} dataStore A pseudo-private property using Date object to store the component's state.\n */\nconst dataStore = new Date().getTime()\n\n/**\n * @class Class to create a component\n */\nexport class Component {\n  /**\n   * Constructor for Component class.\n   * @typedef {object} props An object of property/values to configure the class instance.\n   * @property {string|element} props.container The container element in which to render the component.\n   * @property {state} [props.state] The state object of the component. This can be of type boolean, string, number, object or array.\n   * @property {function} props.render A function that returns nodes to render to the DOM.\n   */\n  constructor(props) {\n    /** @type {props} */\n    if (!props) props = {}\n    this.selector = props.container || props.root ||  'body'\n    \n    if (props.render) {\n      this.render = props.render\n    }\n    \n    if (props.state) {\n      this.state = props.state\n    }\n\n    this.oldNode = null\n    if (this.selector) {\n      this.container = document.querySelector(this.selector)\n    }\n    this.componentShouldUpdate = true\n    \n    this.mounted = false\n    this.element\n    \n    /**\n     * Handle lifecycle methods.\n     */\n    if (props.beforeCreateComponent) {\n      this.beforeCreateComponent = props.beforeCreateComponent\n    }\n    // Alias for React lifecycle hook:\n    if (props.componentWillMount || this.componentWillMount) {\n      this.beforeCreateComponent = props.componentWillMount || this.componentWillMount\n    }\n    if (props.componentWasCreated) {\n      this.componentWasCreated = props.componentWasCreated\n    }\n    // Alias for React lifecycle hook:\n    if (props.componentDidMount || this.componentDidMount) {\n      this.componentWasCreated = props.componentDidMount || this.componentDidMount\n    }\n    if (props.componentWillUpdate) {\n      this.componentWillUpdate = props.componentWillUpdate\n    }\n    if (props.componentDidUpdate) {\n      this.componentDidUpdate = props.componentDidUpdate\n    }\n    if (props.componentWillUnmount) {\n      this.componentWillUnmount = props.componentWillUnmount\n    }\n  }\n\n  /**\n   * Define getters and setters for state.\n   */\n  set state(data) {\n    this[dataStore] = data\n    rAF(() => this.update())\n  }\n\n  get state() {\n    return this[dataStore]\n  }\n  \n  /**\n   * Method to set a component's state.\n   * @param {string|number|boolean|object|array} data The data to set.\n   * @param {number} [position] The index of an array whose data you want to set.\n   */\n  setState(data, position) {\n    if (typeof data === 'function') {\n      const state = data.call(this, this.state)\n      if (typeof state !== 'function' && !!state) this.setState(state)\n    }\n    if (Array.isArray(this.state)) {\n      const state = this.state\n      if (position || position === 0) {\n        if (typeof state[position] === 'object') {\n          mixin(state[position], data)\n          this.state = state\n        } else {\n          state[position] = data\n          this.state = state\n        }\n      } else {\n        this.state = state\n      }\n    } else if (typeof this.state === 'object') {\n      const state = this.state\n      mixin(state, data)\n      this.state = state\n    } else {\n      this.state = data\n    }\n  }\n\n  /**\n   * Function to render component after data changes.\n   * If data is passed as argument, it will be used.\n   * Otherwise state will be used.\n   * @param {boolean|number|string|object|array} [data ]\n   * @returns void\n   */\n  update(data) {\n    if (!this.render) return\n\n    // If componentShouldUpdate is set to false, render one time only.\n    // All other updates will be ignored.\n    if (!this.componentShouldUpdate && this.mounted) return\n\n    // If data is 0 or non-boolean, use,\n    // else use component state.\n    let __data  = this.state\n    if (data !== true && data) __data = data\n\n    if (this.container && typeof this.container === 'string') {\n      this.selector = this.container\n      this.container = document.querySelector(this.container)\n    }\n\n    // Check if vnode already exists.\n    // Used for deciding whether to fire lifecycle events.\n    const __oldNode = this.oldNode\n    const __render = this.render\n    function testIfVNodesDiffer(data) {\n      try {\n        if (JSON.stringify(this.oldNode) === JSON.stringify(__render(data))) {\n          return false\n        } else {\n          return true\n        }\n      } catch(err) {\n        return true\n      }\n    }\n    // Create virtual dom and check if component id already exists in document.\n    const vdom = this.render(__data)\n    let elem\n    if (vdom && vdom.props && vdom.props.id) {\n      try {\n        elem = this.container.querySelector(`#${vdom.props.id}`)\n      } catch(err) {}\n    }\n\n    // If component element id already exists in DOM, \n    // remove it before rendering the component.\n    if (elem && !this.mounted) {\n      elem.parentNode.removeChild(elem)\n    }\n\n    // Patch DOM with component update.\n    this.element = patch(\n      this.oldNode,\n      (this.oldNode = this.render(__data)),\n      this.element,\n      this.container\n    )\n    if (this.mounted && this.oldNode && testIfVNodesDiffer(__data)) {\n      this.componentWillUpdate && this.componentWillUpdate(this)\n    } else {\n      this.beforeCreateComponent && this.beforeCreateComponent(this)\n      this.componentWasCreated && this.componentWasCreated(this)\n      this.mounted = true\n      return\n    }\n    this.componentDidUpdate && testIfVNodesDiffer(__data) && this.componentDidUpdate(this)\n  }\n  \n  /**\n   * Method to destroy component.\n   * First unbind events.\n   * Then remove component element from DOM.\n   * Also null out component properties.\n   * @returns void\n   */\n  unmount() {\n    const self = this\n    const eventWhitelist = ['click', 'dblclick', 'mousedown','mouseup', 'mouseover','mouseout', 'mouseleave', 'select', 'input', 'change', 'keydown', 'keypress', 'keyup', 'submit']\n    if (!this.element) return\n    this.componentWillUnmount && this.componentWillUnmount(this)\n    eventWhitelist.map(event => {\n      this.element.removeEventListener(event, this)\n    })\n    this.container.removeChild(this.element)\n    this.container = undefined\n    for (let key in this) {\n      delete this[key]\n    }\n    delete this.state\n    this.update = undefined\n    this.unmount = undefined\n  }\n}\n\n// Polyfill for Element.closest:\nif (window.Element && !Element.prototype.closest) {\n  Element.prototype.closest = \n  function(s) {\n    let matches = (this.document || this.ownerDocument).querySelectorAll(s)\n    let i\n    let el = this\n    do {\n      i = matches.length\n      while (--i >= 0 && matches.item(i) !== el) {}\n    } while ((i < 0) && (el = el.parentElement))\n    return el\n  }\n}\n","import {patch} from './patch'\nimport {h} from './h'\n\n// Keep tract of rendered nodes.\nconst watchedNodes = {\n  container: undefined,\n  element: undefined,\n  oldNode: undefined\n}\n\n/**\n * A function to create and inject a virtual node into the document. On the first render, the node will be appended to the container. After that, each subsequential render will patch and update the DOM. The first argument can be either a JSX tag or an h function.\n * \n * @param {function} tag A JSX tag or hyperscript function to render.\n * @param {Element|boolean} [container] The element into which the tag will be rendered.\n */\nexport const render = (tag, container) => {\n  if (typeof container === 'string') container = document.querySelector(container)\n  \n  // First time rendering.\n  if (watchedNodes.container !== container) {\n    watchedNodes.container = container\n    watchedNodes.element = undefined\n    watchedNodes.oldNode = undefined\n  }\n  let elem\n  if (tag.props && tag.props.id) {\n    try {\n      if (typeof container === 'string') {\n        elem = document.querySelector(container).querySelector(`#${tag.props.id}`)\n      } else {\n        elem = container.querySelector(`#${tag.props.id}`)\n      }\n    } catch(err) {}\n  }\n  \n  watchedNodes.element = patch(\n    watchedNodes.oldNode,\n    (watchedNodes.oldNode = tag),\n    watchedNodes.element,\n    container\n  )\n}\n","/**\n * Hyperscript function. Enables definition of HTML/SVG using functions.\n * @param {string} type The name of the HTML or SVG tag to create.\n * @param {object} props And object of property/value pairs.\n * @param {string, number, boolean, any[]} children Any child elements.\n */\nexport function h(type, props, ...args) {\n  let node\n  const children = []\n\n  // Go thru args from front to back.\n  while (args.length) {\n    // If child is array, process.\n    if (Array.isArray((node = args.shift()))) {\n      node.map(item => args.push(item))\n    // Else check if child is string or number.\n    } else if (node != null && typeof node !== 'boolean') {\n      typeof node === \"number\" ? node = node + '' : node\n      children.push(node)\n    }\n  }\n  \n  return typeof type === \"string\" \n    ? {type, props: props || {}, children } \n    : type(props || {}, children)\n}\n"],"names":["mixin","obj1","obj2","result","i","patch","oldNode","newNode","element","container","diffAndPatch","svg","nextSibling","insertBefore","createElement","type","oldProps","props","keys","forEach","value","key","oldValue","setProps","len","children","length","oldLen","oldKeyed","oldElements","keyed","k","oldElement","childNodes","oldChild","oldKey","getKey","j","newChild","newKey","keyedNode","removeElement","reusableNode","nodeValue","data","document","body","name","style","test","toLowerCase","namespaceURI","setAttributeNS","setAttribute","removeAttribute","node","createTextNode","createElementNS","map","appendChild","child","removeChild","hasOwnProperty","p","defineProperty","rAF","window","requestAnimationFrame","webkitRequestAnimationFrame","mozRequestAnimationFrame","msRequestAnimationFrame","cb","setTimeout","dataStore","Date","getTime","Component","selector","root","render","state","this","querySelector","componentShouldUpdate","mounted","beforeCreateComponent","componentWillMount","componentWasCreated","componentDidMount","componentWillUpdate","componentDidUpdate","componentWillUnmount","position","call","setState","Array","isArray","babelHelpers.typeof","__data","__render","vdom","elem","id","err","parentNode","testIfVNodesDiffer","JSON","stringify","removeEventListener","event","undefined","update","unmount","_this2","Element","prototype","closest","s","matches","ownerDocument","querySelectorAll","el","item","parentElement","watchedNodes","args","shift","push","tag"],"mappings":"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"}