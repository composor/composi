{"version":3,"file":"composi.js","sources":["../lib/utils/getKey.js","../lib/utils/mixin.js","../lib/utils/setProps.js","../lib/utils/createElement.js","../lib/utils/createNode.js","../lib/utils/removeElement.js","../lib/patch.js","../lib/utils/updateElement.js","../lib/component.js","../lib/render.js","../lib/h.js"],"sourcesContent":["/**\n * @description Function to get a node's key.\n * @param {object} node A virtual node.\n * @returns {string|number} key\n */\nexport function getKey(node) {\n  if (node && node.props) {\n    return node.props.key\n  }\n}\n","/**\n * @description A function to merge two objects together. The properties of the second object will overwrite any matching properties in the first object.\n * @param {object} obj1 The first object to merge.\n * @param {object} obj2 The second object to merge.\n * @returns {object} obj1 Returns the first parameter.\n */\nexport function mixin(obj1, obj2) {\n  const result = {}\n  for (let i in obj1) {\n    result[i] = obj1[i]\n  }\n  for (let i in obj2) {\n    result[i] = obj2[i]\n  }\n  return result\n}\n","import {mixin} from './mixin'\n\n/**\n * @description Function to set properties and attributes on element.\n * @param {node} element \n * @param {string} name \n * @param {string|number|boolean} value \n * @param {string|number|boolean} oldValue \n * @returns void\n */\nexport function setProps(element, name, value, oldValue) {\n  if (name === 'key') {\n  } else if (name === 'style' && typeof value !== 'string') {\n    for (let name in mixin(oldValue, (value = value || {}))) {\n      element.style[name] = value[name] + \"\" || ''\n    }\n  } else {\n    if (value === 0) value = value + \"\"\n    // Handle cases where 'className' is used:\n    if (name === 'className') name = 'class'\n    if (name[0]=='o' && name[1]=='n') name = name.toLowerCase()\n    if (name === 'dangerouslySetInnerHTML') {\n      element.innerHTML = value\n      return\n    }\n    // Cannot set SVG properties this way, so test:\n    if (element.namespaceURI !== 'http://www.w3.org/2000/svg') element[name] = value\n\n    // In case of inline events, value would be function.\n    // This avoids resetting them if they were set above as a property.\n    if (typeof value !== 'function') {\n      if (!!value) {\n        // Support SVG 'xlink:href' property:\n        if (name === 'xlink-href') {\n          element.setAttributeNS('http://www.w3.org/1999/xlink', 'href', value)\n          element.setAttribute('href', value)\n        } else {\n          element.setAttribute(name, value)\n        }\n      } else {\n        element.removeAttribute(name)\n      }\n    }\n  }\n}\n","import {createNode} from './createNode'\n\n/**\n * @description Function to convert hyperscript/JSX into DOM nodes.\n * @param {Function} node A node to create. This may be a hyperscript function or a JSX tag which gets converted to hyperscript during transpilation.\n * @param {boolean} isSVG Whether the node is SVG or not.\n * @returns {Element} \n */\nexport function createElement(node, isSVG) {\n  return typeof node === \"string\" ? document.createTextNode(node) : createNode(node, isSVG)\n}\n","import {createElement} from './createElement'\nimport {setProps} from './setProps'\n\n/**\n * @description Function to create an HTML or SVG node.\n * @param {object} node A virtual node object defining an element to be created.\n * @param {boolean} isSVG Whether the node is SVG or not.\n * @returns {Element}\n */\nexport function createNode(node, isSVG) {\n  let element\n  if (isSVG = isSVG || node.type === 'svg') {\n    element = document.createElementNS(\"http://www.w3.org/2000/svg\", node.type)\n  } else {\n    element = document.createElement(node.type)\n  }\n\n  Object.keys(node.props).forEach(key => setProps(element, key, node.props[key]))\n  node.children.map(child => element.appendChild(createElement(child, isSVG)))\n  return element\n}\n","/**\n * @description Function to remove element from DOM.\n * @param {node} container The container of the element to remove.\n * @param {node} element The element to remove.\n * @returns {undefined} void\n */\nexport const removeElement = (container, element) => container.removeChild(element)\n","import {getKey} from './utils/getKey'\nimport {createElement} from './utils/createElement'\nimport {updateElement} from './utils/updateElement'\nimport {removeElement} from './utils/removeElement'\n\n/**\n * @constructor \n * @param {Object|undefined|null} oldNode Virtual node defining original node or null.\n * @param {object} newNode A virtual node defining the new node.\n * @param {Element|undefined} element The component root element.\n * @param {Element} container The container element in which component is rendered.\n * @returns {Element}\n */\nexport function patch(oldNode, newNode, element, container) {\n  return diffAndPatch(container || document.body, element, oldNode, newNode)\n}\n\n/**\n * @description Function to patch DOM. Diffs virtual nodes, then patches the DOM.\n * @param {Element} container \n * @param {Element|undefined} element \n * @param {object} oldNode \n * @param {object} newNode \n * @param {boolean} isSVG \n * @param {object} nextSibling \n * @returns {Element}\n */\nfunction diffAndPatch(container, element, oldNode, newNode, isSVG, nextSibling) {\n  // There is no oldNode, so this is first render.\n  if (oldNode == null) {\n    element = container.insertBefore(createElement(newNode, isSVG), element)\n  // There's an oldNode, so patch.\n  } else if (newNode.type != null && newNode.type === oldNode.type) {\n    updateElement(element, oldNode.props, newNode.props)\n\n    isSVG = isSVG || newNode.type === \"svg\"\n    const len = newNode.children.length\n    let oldLen = oldNode.children.length\n    let oldKeyed = {}\n    let oldElements = []\n    let keyed = {}\n\n    let k = 0\n    while (k < oldLen) {\n      let oldElement = (oldElements[k] = element.childNodes[k])\n      let oldChild = oldNode.children[k]\n      let oldKey = getKey(oldChild)\n      if (null != oldKey) oldKeyed[oldKey] = [oldElement, oldChild]\n      k++\n    }\n\n    let i = 0, j = 0\n    while (j < len) {\n      let oldElement = oldElements[i]\n      let oldChild = oldNode.children[i]\n      let newChild = newNode.children[j]\n      let oldKey = getKey(oldChild)\n      if (keyed[oldKey]) {\n        i++\n        continue\n      }\n      \n      let newKey = getKey(newChild)\n      let keyedNode = oldKeyed[newKey] || []\n      if (null == newKey) {\n        if (null == oldKey) {\n          diffAndPatch(element, oldElement, oldChild, newChild, isSVG)\n          j++\n        }\n        i++\n      } else {\n        oldKey === newKey ? diffAndPatch(element, keyedNode[0], keyedNode[1], newChild, isSVG) && i++ :\n        keyedNode[0] ? element.insertBefore(keyedNode[0], oldElement) && diffAndPatch(element, keyedNode[0], keyedNode[1], newChild, isSVG) : diffAndPatch(element, oldElement, null, newChild, isSVG)\n        \n        keyed[newKey] = newChild\n        j++\n      }\n    }\n\n    while (i < oldLen) {\n      let oldChild = oldNode.children[i]\n      let oldKey = getKey(oldChild)\n      if (null == oldKey) removeElement(element, oldElements[i])\n      i++\n    }\n\n    Object.keys(oldKeyed).forEach(key => {\n      let keyedNode = oldKeyed[key]\n      let reusableNode = keyedNode[1]\n      if (!keyed[reusableNode.props.key]) {\n        removeElement(element, keyedNode[0])\n      }\n    })\n  } else if (element && newNode !== element.nodeValue) {\n    if (typeof newNode === \"string\" && typeof oldNode === \"string\") {\n      element.nodeValue = newNode\n    } else {\n      element = container.insertBefore(\n        createElement(newNode, isSVG),\n        (nextSibling = element)\n      )\n      removeElement(container, nextSibling, oldNode.data)\n    }\n  }\n  return element\n}\n","import {mixin} from './mixin'\nimport {setProps} from './setProps'\n\n/**\n * @description Update an element with new values for properties and/or children.\n * @param {Element} element \n * @param {node} oldProps \n * @param {object} props \n * @returns {undefined} void\n */\nexport function updateElement(element, oldProps, props) {\n  Object.keys(mixin(oldProps, props)).forEach(key => {\n    let value = props[key]\n    let oldValue = key === \"value\" || key === \"checked\" ? element[key] : oldProps[key]\n    if (value !== oldValue) setProps(element, key, value, oldValue)\n  })\n}\n","import {h} from './h'\nimport {patch} from './patch'\nimport {mixin} from './utils/mixin'\n\n/**\n * @description A cross-browser normalization/polyfill for requestAnimationFrame.\n */\nvar rAF = window.requestAnimationFrame\n  || window.webkitRequestAnimationFrame\n  || window.mozRequestAnimationFrame\n  || window.msRequestAnimationFrame\n  || function(cb) { return setTimeout(cb, 16) }\n\n/**\n * @description This is a Time Object used as a key to create a pseudo-private property in the Component class for holding state.\n * @type {Object} dataStore A Date object to use as pseudo-private key to store the component's state.\n */\nconst dataStore = new Date().getTime()\n\n/**\n * @description Component can be instantiated with the new keyword, or extended to create a custom version of the class.\n * @class Class to create a component.\n * @example New instance of Component class:\n * const title = new Component({\n *   container: 'header',\n *   state: 'World',\n *   render: message => <h1>Hello, {message}!</h1>\n * })\n * @example Extending Component class:\n * class UserList extends Component {\n *   constructor(props) {\n *     super(props)\n *     this.state = users\n *     this.container = 'section'\n *   }\n *   render(users) {\n *     return (\n *      <ul class='user-list'>\n *        {\n *          users.map(user => <li>{user.name}</li>)\n *        }\n *      </ul>\n *     )\n *   }\n * }\n */\nexport class Component {\n  /**\n   * @description Constructor for Component class.\n   * @typedef {object} props An object of property/values to configure the class instance.\n   * @property {string|element} props.container The container element in which to render the component.\n   * @property {state} [props.state] The state object of the component. This can be of type boolean, string, number, object or array.\n   * @property {function} props.render A function that returns nodes to render to the DOM.\n   * @constructs Component\n   */\n  constructor(props) {\n    if (!props) props = {}\n    /** @property {string} */\n    this.selector = props.container || props.root ||  'body'\n    \n    if (props.render) {\n      /** @property {Function} */\n      this.render = props.render\n    }\n    \n    if (props.state) {\n      /** @property {boolean|number|string|object|array} */\n      this.state = props.state\n    }\n\n    /** @property {null, Object} */\n    this.oldNode = null\n    if (this.selector) {\n      /** @property {Element} */\n      this.container = document.querySelector(this.selector)\n    }\n    /** @property {boolean} */\n    this.componentShouldUpdate = true\n    \n    /** @property {boolean} */\n    this.mounted = false\n\n    /** \n     * @property {Element} \n     * @default {undefined}\n    */\n    this.element\n    \n    /**\n     * @description Handle lifecycle hooks.\n     */\n    if (props.componentWillMount || props.beforeCreateComponent) {\n      /** \n       * @type {Function} - A function to execute before the Component is created.\n       * @property Component#componentWillMount\n      */\n      this.componentWillMount = props.componentWillMount || props.beforeCreateComponent\n    }\n    if (this.beforeCreateComponent) {\n      /** \n       * @type {Function} - A function to execute before the Component is created.\n       * @property Component#componentWillMount\n       */\n      this.componentWillMount = this.beforeCreateComponent\n    }\n    if (props.componentDidMount || props.componentWasCreated) {\n      /** \n       * @type {Function} - A function to execute after the component is created.\n       * @property Component#componentDidMount\n       */\n      this.componentDidMount = props.componentDidMount || props.componentWasCreated\n    }\n    // Alias for React lifecycle hook:\n    if (this.componentWasCreated) {\n      /** \n       * @type {Function} - A function to execute after the component is created.\n       * @property Component#componentDidMount\n       */\n      this.componentDidMount = this.componentWasCreated\n    }\n    if (props.componentWillUpdate) {\n      /** \n       * @type {Function} - A function to execute before the component is updated.\n       * @property Component#componentWillUpdate\n       */\n      this.componentWillUpdate = props.componentWillUpdate\n    }\n    if (props.componentDidUpdate) {\n      /** \n       * @type {Function} - A function to execute after the component is updated.\n       * @property Component#componentDidUpdate\n       */\n      this.componentDidUpdate = props.componentDidUpdate\n    }\n    if (props.componentWillUnmount) {\n      /** \n       * @type {Function} - A function to execute before the component is destroyed.\n       * @property Component#componentWillUnmount\n       */\n      this.componentWillUnmount = props.componentWillUnmount\n    }\n  }\n\n  /**\n   * @description This is getter to access the component's state using the pseudo-private key dataStore.\n   * @returns {boolean|number|string|object|any[]} - The component's state\n   */\n  get state() {\n    return this[dataStore]\n  }\n\n  /**\n   * @description This is setter to define the component's state. It uses the dataStore object as a pseudo-private key.\n   * method\n   * @param {string|number|boolean|object|array} data - Data to set as comp0nent state. \n   * @returns {undefined} void\n   */\n  set state(data) {\n    this[dataStore] = data\n    rAF(() => this.update())\n  }\n  \n  /**\n   * @description Method to set a component's state. This accepts simple types or Objects. If updating an array, you can pass in the data and the position (number) in the array to update. Optionally you can pass a callback. This receives the state as its argument. You need to return the state changes in order to update the component's state.\n   * @example\n   * this.setState(true)\n   * this.setState(0)\n   * this.setState({name: 'Joe'})\n   * this.setState([1,2,3])\n   * this.setState(prevState => prevState + 1)\n   * @property Component#setState\n   * @param {string|number|boolean|object|array|Function} data - The data to set.\n   * @param {number} [position] The index of an array whose data you want to set.\n   * @returns {undefined} void\n   */\n  setState(data, position) {\n    if (typeof data === 'function') {\n      const state = data.call(this, this.state)\n      if (typeof state !== 'function' && !!state) this.setState(state)\n    } else if (Array.isArray(this.state)) {\n      const state = this.state\n      if (position || position === 0) {\n        if (typeof state[position] === 'object') {\n          this.state = mixin(state[position], data)\n        } else {\n          state[position] = data\n          this.state = state\n        }\n      } else {\n        this.state = state\n      }\n    } else if (typeof this.state === 'object') {\n      const state = this.state\n      this.state = mixin(state, data)\n    } else {\n      this.state = data\n    }\n  }\n\n  /**\n   * @description Function to render component after data changes.\n   * If data is passed as argument, it will be used.\n   * Otherwise state will be used.\n   * @property Component#update\n   * @param {boolean|number|string|object|array} [data]\n   * @returns {undefined} void\n   */\n  update(data) {\n    if (!this.render) return\n\n    // If componentShouldUpdate is set to false, render one time only.\n    // All other updates will be ignored.\n    if (!this.componentShouldUpdate && this.mounted) return\n\n    // If data is 0 or non-boolean, use,\n    // else use component state.\n    let __data  = this.state\n    if (data !== true && data) __data = data\n\n    if (this.container && typeof this.container === 'string') {\n      this.selector = this.container\n      this.container = document.querySelector(this.container)\n    }\n\n    // Check if vnode already exists.\n    // Used for deciding whether to fire lifecycle events.\n    const __oldNode = this.oldNode\n    const __render = this.render\n    function testIfVNodesDiffer(data) {\n      try {\n        if (JSON.stringify(this.oldNode) === JSON.stringify(__render(data))) {\n          return false\n        } else {\n          return true\n        }\n      } catch(err) {\n        return true\n      }\n    }\n    // Create virtual dom and check if component id already exists in document.\n    const vdom = this.render(__data)\n    let elem\n    if (vdom && vdom.props && vdom.props.id) {\n      try {\n        elem = this.container.querySelector(`#${vdom.props.id}`)\n      } catch(err) {\n        return false\n      }\n    }\n\n    // If component element id already exists in DOM, \n    // remove it before rendering the component.\n    if (elem && !this.mounted) {\n      elem.parentNode.removeChild(elem)\n    }\n\n    // Patch DOM with component update.\n    this.element = patch(\n      this.oldNode,\n      (this.oldNode = this.render(__data)),\n      this.element,\n      this.container\n    )\n    if (this.mounted && this.oldNode && testIfVNodesDiffer(__data)) {\n      this.componentWillUpdate && this.componentWillUpdate(this)\n    } else {\n      this.componentWillMount && this.componentWillMount(this)\n      this.componentDidMount && this.componentDidMount(this)\n      this.mounted = true\n      return\n    }\n    this.componentDidUpdate && testIfVNodesDiffer(__data) && this.componentDidUpdate(this)\n  }\n  \n  /**\n   * @description Method to destroy component.\n   * First unbind events.\n   * Then remove component element from DOM.\n   * Also null out component properties.\n   * @property Component#unmount\n   * @returns {undefined} void\n   */\n  unmount() {\n    const self = this\n    const eventWhitelist = ['click', 'dblclick', 'mousedown','mouseup', 'mouseover','mouseout', 'mouseleave', 'select', 'input', 'change', 'keydown', 'keypress', 'keyup', 'submit']\n    if (!this.element) return\n    this.componentWillUnmount && this.componentWillUnmount(this)\n    eventWhitelist.map(event => {\n      this.element.removeEventListener(event, this)\n    })\n    this.container.removeChild(this.element)\n    this.container = undefined\n    for (let key in this) {\n      delete this[key]\n    }\n    delete this.state\n    this.update = undefined\n    this.unmount = undefined\n  }\n}\n\n/** @description Polyfill for Element.closest. */\nif (window.Element && !Element.prototype.closest) {\n  /**\n   * Extends Element to enable finding closest ancestor based on provided selector.\n   * @param {string} s Selector to query.\n   */\n  Element.prototype.closest = \n  function(s) {\n    let matches = (this.document || this.ownerDocument).querySelectorAll(s)\n    let i\n    let el = this\n    do {\n      i = matches.length\n      while (--i >= 0 && matches.item(i) !== el) {}\n    } while ((i < 0) && (el = el.parentElement))\n    return el\n  }\n}\n","import {patch} from './patch'\nimport {h} from './h'\n\n// Keep tract of rendered nodes.\n/**\n * @description Object literal to keep tract of rendered nodes.\n * @attribute {Element} container The element in which the component is rendered.\n * @attribute {Element} element The root element of the component tree.\n * @attribute {object} oldNode A VNode (virtual node in object literal format) defining the last render of the component.\n */\nconst watchedNodes = {\n  container: undefined,\n  element: undefined,\n  oldNode: undefined\n}\n\n/**\n * @description A function to create and inject a virtual node into the document. On the first render, the node will be appended to the container. After that, each subsequential render will patch and update the DOM. The first argument can be either a JSX tag or an h function.\n * \n * @param {function} tag A JSX tag or hyperscript function to render.\n * @param {Element|boolean} [container] The element into which the tag will be rendered.\n * @returns {undefined} void\n */\nexport const render = (tag, container) => {\n  if (typeof container === 'string') container = document.querySelector(container)\n  \n  // First time rendering.\n  if (watchedNodes.container !== container) {\n    watchedNodes.container = container\n    watchedNodes.element = undefined\n    watchedNodes.oldNode = undefined\n  }\n  let elem\n  if (tag.props && tag.props.id) {\n    try {\n      if (typeof container === 'string') {\n        elem = document.querySelector(container).querySelector(`#${tag.props.id}`)\n      } else {\n        elem = container.querySelector(`#${tag.props.id}`)\n      }\n    } catch(err) {}\n  }\n  \n  watchedNodes.element = patch(\n    watchedNodes.oldNode,\n    (watchedNodes.oldNode = tag),\n    watchedNodes.element,\n    container\n  )\n}\n","/**\n * @description Hyperscript function. Enables definition of HTML/SVG using functions.\n * @param {string} type - The name of the HTML or SVG tag to create.\n * @param {object} props - And object of property/value pairs.\n * @param {string|number|boolean|any[]} args - Any child elements.\n * @returns {object} A virtual node describing an element.\n * @example Virtual node with string as content:\n * const title = h('h1', {class: 'main-title'}, 'This is the Titel!')\n * @example Virtual node with children:\n * const list = h(\n *   'ul',\n *   {class: 'list'},\n *   [\n *     h('li', {}, 'One'),\n *     h('li', {}, 'Two'),\n *     h('li', {}, 'Three')\n *   ]\n * )\n */\nexport function h(type, props, ...args) {\n  let node\n  const children = []\n\n  // Go thru args from front to back.\n  while (args.length) {\n    // If child is array, process.\n    if (Array.isArray((node = args.shift()))) {\n      node.map(item => args.push(item))\n    // Else check if child is string or number.\n    } else if (node != null && typeof node !== 'boolean') {\n      typeof node === \"number\" ? node = node + '' : node\n      children.push(node)\n    }\n  }\n  \n  if (typeof type === 'string') {\n    return {type, props: props || {}, children } \n  } else {\n    return type(props || {}, children)\n  }\n}\n"],"names":["getKey","node","props","key","mixin","obj1","obj2","result","i","setProps","element","name","value","oldValue","style","toLowerCase","innerHTML","namespaceURI","setAttributeNS","setAttribute","removeAttribute","createElement","isSVG","document","createTextNode","type","createElementNS","keys","forEach","children","map","appendChild","child","removeElement","container","removeChild","patch","oldNode","newNode","diffAndPatch","nextSibling","insertBefore","oldProps","len","length","oldLen","oldKeyed","oldElements","keyed","k","oldElement","childNodes","oldChild","oldKey","j","newChild","newKey","keyedNode","reusableNode","nodeValue","data","body","rAF","window","requestAnimationFrame","webkitRequestAnimationFrame","mozRequestAnimationFrame","msRequestAnimationFrame","cb","setTimeout","dataStore","Date","getTime","Component","selector","root","render","state","this","querySelector","componentShouldUpdate","mounted","componentWillMount","beforeCreateComponent","componentDidMount","componentWasCreated","componentWillUpdate","componentDidUpdate","componentWillUnmount","position","call","setState","Array","isArray","babelHelpers.typeof","__data","__render","vdom","elem","id","err","parentNode","testIfVNodesDiffer","JSON","stringify","removeEventListener","event","undefined","update","unmount","_this2","Element","prototype","closest","s","matches","ownerDocument","querySelectorAll","el","item","parentElement","watchedNodes","args","shift","push","tag"],"mappings":"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"}