{"version":3,"file":"composi.js","sources":["../lib/patch.js","../lib/mixin.js","../lib/component.js","../lib/injectElement.js","../lib/pubsub.js","../lib/h.js","../lib/uuid.js"],"sourcesContent":["/**\n * A function to merge two objects together. The properties of the second object will overwrite any matching properties in the first object.\n * @param {Object} obj1 The first object to merge.\n * @param {Object} obj2 The second object to merge.\n */\nfunction mixin(obj1, obj2) {\n  const obj = {}\n  Object.keys(obj1).map(key => obj[key] = key)\n  Object.keys(obj2).map(key => obj[key] = key)\n  return obj\n}\n\n/**\n * @constructor \n * @param {node} oldNode Original node or null.\n * @param {node} node New node.\n * @param {node} element The component root element.\n * @param {node} parent Parent node in which component is rendered.\n */\nexport function patch(oldNode, node, element, parent) {\n  element = diffAndPatch(parent || document.body, element, oldNode, node)\n  return element\n}\n\n/**\n * Patch functions:\n * setProps \n * createNode\n * createElement\n * getKey\n * updateElement\n * removeElement\n * diffAndPatch\n */\n\n/**\n * Function to set properties and attributes on element.\n * @param {node} element \n * @param {string} name \n * @param {string|number|boolean} value \n * @param {string|number|boolean} oldValue \n */\nfunction setProps(element, name, value, oldValue) {\n  if (name === 'key') {\n  } else if (name === \"style\") {\n    for (let key of mixin(oldValue, (value = value || {}))) {\n      element.style[key] = value[key] || ''\n    }\n  } else {\n    try {\n      element[name] = value\n    } catch (err) {}\n    typeof value !== \"function\" && value ? element.setAttribute(name, value) : element.removeAttribute(name)\n  }\n}\n\n/**\n * Function to create an HTML or SVG node.\n * @param {node} node node A node to create.\n * @param {svg} svg Whether the node is SVG or not.\n */\nfunction createNode(node, svg) {\n  const element = (svg = svg || node.type === \"svg\")\n  ? document.createElementNS(\"http://www.w3.org/2000/svg\", node.type)\n  : document.createElement(node.type)\n\n  for (let key in node.props) setProps(element, key, node.props[key])\n  node.children.map(child => element.appendChild(createElement(child, svg)))\n  return element\n}\n\n/**\n * Function to convert hyperscript/JSX into DOM nodes.\n * @param {jsx|hyperscript} node A node to create.\n * @param {svg} svg Whether the node is SVG or not.\n */\nexport function createElement(node, svg) {\n  return typeof node === \"string\" ? document.createTextNode(node) : createNode(node, svg)\n}\n\n/**\n * Function to get a node's key.\n * @param {node} node \n */\nfunction getKey(node) {\n  if (node && node.props) {\n    return node.key\n  }\n}\n\n/**\n * Update an element with new values for properties and/or children.\n * @param {Element} element \n * @param {node} oldProps \n * @param {object} props \n */\nfunction updateElement(element, oldProps, props) {\n  for (let key in mixin(oldProps, props)) {\n    let value = props[key]\n    , oldValue = key === \"value\" || key === \"checked\" ? element[key] : oldProps[key]\n\n    if (value !== oldValue) setProps(element, key, value, oldValue)\n  }\n}\n\n/**\n * Function to remove element from DOM.\n * @param {node} parent The parent of the element to remove.\n * @param {node} element The element to remove.\n */\nconst removeElement = (parent, element) => parent.removeChild(element)\n\n/**\n * Function to patch DOM. Diffs virtual nodes, then patches the DOM.\n * @param {node} parent \n * @param {node} element \n * @param {node} oldNode \n * @param {node} node \n * @param {boolean} svg \n * @param {node} nextSibling \n */\nfunction diffAndPatch(parent, element, oldNode, node, svg, nextSibling) {\n  if (oldNode == null) {\n    element = parent.insertBefore(createElement(node, svg), element)\n  } else if (node.type != null && node.type === oldNode.type) {\n    updateElement(element, oldNode.props, node.props)\n\n    svg = svg || node.type === \"svg\"\n    const len = node.children.length\n    , oldLen = oldNode.children.length\n    , oldKeyed = {}\n    , oldElements = []\n    , keyed = {}\n\n    let k = 0\n    while (k < oldLen) {\n      let oldElement = (oldElements[k] = element.childNodes[k])\n      , oldChild = oldNode.children[k]\n      , oldKey = getKey(oldChild)\n      if (null != oldKey) oldKeyed[oldKey] = [oldElement, oldChild]\n      k++\n    }\n\n    let i = 0\n    , j = 0\n\n    while (j < len) {\n      let oldElement = oldElements[i]\n      , oldChild = oldNode.children[i]\n      , newChild = node.children[j]\n      , oldKey = getKey(oldChild)\n  \n      if (keyed[oldKey]) {\n        i++\n        continue\n      }\n      \n      let newKey = getKey(newChild)\n      , keyedNode = oldKeyed[newKey] || []\n\n      if (null == newKey) {\n        if (null == oldKey) {\n          diffAndPatch(element, oldElement, oldChild, newChild, svg)\n          j++\n        }\n        i++\n      } else {\n        oldKey === newKey ? diffAndPatch(element, keyedNode[0], keyedNode[1], newChild, svg) && i++ :\n        keyedNode[0] ? element.insertBefore(keyedNode[0], oldElement) && diffAndPatch(element, keyedNode[0], keyedNode[1], newChild, svg) : diffAndPatch(element, oldElement, null, newChild, svg)\n        \n        keyed[newKey] = newChild\n\n        j++\n      }\n    }\n\n    while (i < oldLen) {\n      let oldChild = oldNode.children[i]\n      , oldKey = getKey(oldChild)\n      if (null == oldKey) removeElement(element, oldElements[i])\n      i++\n    }\n\n    for (let key in oldKeyed) {\n      let keyedNode = oldKeyed[key]\n      , reusableNode = keyedNode[1]\n      if (!keyed[reusableNode.props.key]) {\n        removeElement(element, keyedNode[0])\n      }\n    }\n  } else if (element && node !== element.nodeValue) {\n    if (typeof node === \"string\" && typeof oldNode === \"string\") {\n      element.nodeValue = node\n    } else {\n      element = parent.insertBefore(\n        createElement(node, svg),\n        (nextSibling = element)\n      )\n      removeElement(parent, nextSibling, oldNode.data)\n    }\n  }\n  return element\n}\n","/**\n * A mixin function used for updating component state.\n * @param {object} obj1 An object as the target.\n * @param {object} obj2 An object of properties to target.\n */\nexport const mixin = (obj1, obj2) => {\n  Object.keys(obj2).forEach(p => {\n    if (obj2.hasOwnProperty(p)) {\n      Object.defineProperty(obj1, p, {\n        value: obj2[p],\n        writable: true,\n        enumerable: false,\n        configurable: true\n      })\n    }\n  })\n}\n","import {h} from './h'\nimport {patch} from './patch'\nimport {mixin} from './mixin'\n\nvar rAF = window.requestAnimationFrame\n  || window.webkitRequestAnimationFrame\n  || window.mozRequestAnimationFrame\n  || window.msRequestAnimationFrame\n  || function(cb) { return setTimeout(cb, 16); };\n\n/**\n * @type {object} dataStore A pseudo-private property using Date object to store the component's state.\n */\nconst dataStore = new Date().getTime()\n\n/**\n * @type {function} noop A no operation function.\n */\nconst noop = () => {}\n\n/**\n * @class Class to create a component\n */\nexport class Component {\n  /**\n   * Constructor for Component class.\n   * @typedef {object} props An object of property/values to configure the class instance.\n   * @property {string|element} props.root The root element in which to render the component.\n   * @property {state} [props.state] The state object of the component. This can be of type boolean, string, number, object or array.\n   * @property {function} props.render A function that returns nodes to render to the DOM.\n   * @property {object} [props.styles] An object defining a component-scoped stylesheet.\n   * @property {object|array} [props.interactions] An object or array of objects defining user interactions. These are events with callbacks registed on the component or its child elements.\n   */\n  constructor(props) {\n    if (!props) props = {}\n    this.props = props\n    this.selector = this.props.element || this.props.root || 'body'\n    if (this.props.render) {\n      this.render = this.props.render\n    }\n    this[dataStore] = this.props.state\n    this.oldNode = null;\n    this.styles = this.props.styles\n    if (this.selector) {\n      this.root = document.querySelector(this.selector)\n    }\n    \n    this.scopedStylesheet = false\n    this.mounted = false\n    this.element\n    this.interactionsAreRegistered = false\n    \n    /**\n     * Create virtual stylesheet for component.\n     */\n    this.createComponentStyles = function() {\n      let sharedSheet = null\n\n      const unitlessProps = {\n        columnCount: true,\n        fillOpacity: true,\n        flex: true,\n        flexGrow: true,\n        flexShrink: true,\n        fontWeight: true,\n        lineClamp: true,\n        lineHeight: true,\n        opacity: true,\n        order: true,\n        orphans: true,\n        widows: true,\n        zIndex: true,\n        zoom: true\n      }\n\n      function flatten(array) {\n        const flat = Array.prototype.concat(array)\n        for (let i = 0; i < flat.length; i++) {\n          if (Array.isArray(flat[i])) {\n            flat.splice(i, 1, flat[i--])\n          }\n        }\n        return flat\n      }\n\n      function createStyleSheet(options) {\n        if (!(this instanceof createStyleSheet)) {\n          return new createStyleSheet(options)\n        }\n        options || (options = {})\n        options.prefix = !options.hasOwnProperty(\"prefix\") ? true : !!options.prefix\n        options.unit = options.hasOwnProperty(\"unit\") ? options.unit : \"px\"\n\n        this._sheet = null\n        this._prefix = null\n\n        this.css = function (element, styles, selector) {\n          if (styles == null) return \"\"\n          if (this._sheet == null) {\n            this._sheet = sharedSheet = (sharedSheet || createSheet())\n          }\n          selector = element\n\n          const rules = rulesFromStyles(selector, styles)\n          if (options.prefix || options.unit !== \"\") {\n            rules.forEach(function(set) {\n              if (options.unit !== \"\") {\n                addUnit(set[1], options.unit)\n              }\n            })\n          }\n\n          insertRules(rules, this._sheet)\n        }\n      }\n\n      function createSheet() {\n        if (document.head == null) {\n          throw new Error(\"Can't add stylesheet before <head> is available. Make sure your document has a head element.\")\n        }\n        const style = document.createElement(\"style\")\n        style.id = \"styles_\" + Math.random().toString(16).slice(2, 8)\n        document.head.appendChild(style)\n        return style.sheet\n      }\n\n      function rulesFromStyles(selector, styles) {\n        if (!Array.isArray(styles)) styles = [styles]\n        const style = {}\n        let rules = []\n        styles = flatten(styles)\n        styles.forEach(function(block) {\n          for (let prop in block) {\n            let value = block[prop]\n            if (isPlainObject(value) || Array.isArray(value)) {\n              rules = rules.concat(\n                rulesFromStyles(combineSelectors(selector, prop), value)\n              )\n            } else {\n              if (prop === \"content\") value = \"'\"+value+\"'\"\n              style[prop] = value\n            }\n          }\n        })\n\n        rules.push([ selector, style ])\n        return rules\n      }\n\n      function insertRules(rules, sheet) {\n        window.sheet = sheet\n        function hyphenate(str) {\n          return str.replace(/[A-Z]/g, function($0) { return '-'+$0.toLowerCase() })\n        }\n        rules.forEach(function(rule) {\n          const pairs = []\n          for (let prop in rule[1]) {\n            pairs.push(hyphenate(prop) + \":\" + rule[1][prop])\n          }\n          if (pairs.length > 0) {\n            const rulez = rule[0] ? rule[0] : ''\n            sheet.insertRule(rulez + \"{\" + pairs.join(\";\") + \"}\", 0)\n          }\n        })\n      }\n\n      function combineSelectors(parent, child) {\n        const pseudoRe = /^[:\\[]/\n        const parents = parent.split(\",\"), children = child.split(\",\")\n        return parents.map(function(parent) {\n          return children.map(function(part) {\n            const separator = pseudoRe.test(part) ? \"\" : \" \"\n            return parent + separator + part\n          }).join(\",\")\n        }).join(\",\")\n      }\n\n      function addUnit(style, unit) {\n        for (let prop in style) {\n          let value = style[prop] + \"\"\n          if (!isNaN(value) && !unitlessProps[prop]) {\n            value = value + unit\n          }\n          style[prop] = value\n        }\n        return style\n      }\n\n      function isPlainObject(obj) {\n        return obj === Object(obj) && Object.prototype.toString === obj.toString\n      }\n\n      const stylesheets = {}\n      stylesheets.css = createStyleSheet().css\n      return stylesheets\n    }\n\n    /**\n     * Register events on the component or its child nodes.\n     */\n    this.handleEvents = function() {\n      if (!this.interactions) return\n      const self = this\n      let bubble = false\n      if (this.mounted) return\n      if (Array.isArray(this.interactions)) {\n        if (!this.interactions.length || this.interactionsAreRegistered) return\n        this.interactions.forEach(function(action) {\n          bubble = action.bubble\n          if (action && action.element === 'self' || action && !action.element) {\n            self.root.addEventListener(action.event, action.callback, bubble)\n          } else {\n            self.root.addEventListener(action.event, function(e) {\n              let target = e.target\n              if (e.target.nodeType === 3) {\n                target = e.target.parentNode\n              }\n              const els = [].slice.call(self.element.querySelectorAll(action.element))\n              const len = els.length\n              let i = 0\n              while (i < len) {\n                if (e.target.closest(action.element) === els[i]) {\n                  action.callback.call(els[i], e)\n                  break\n                }\n                i++\n              }\n            })\n          }\n          self.interactionsAreRegistered = true\n        })\n      }\n    }\n    \n    /**\n     * Check for interactions.\n     */\n    if (this.props.interactions) {\n      this.interactions = this.props.interactions\n    }\n    this.interactions && this.handleEvents()\n\n    /**\n     * Attach any functions provided in methods property as component methods.\n     */\n    if (this.props.methods) {\n      const self = this\n      for (let method in this.props.methods) {\n        self[method] = this.props.methods[method]\n      }\n    }\n    \n    /**\n     * Handle lifecycle methods.\n     */\n    if (this.props.componentWasCreated) {\n      this.componentWasCreated = this.props.componentWasCreated\n    }\n    if (this.props.componentWillUpdate) {\n      this.componentWillUpdate = this.props.componentWillUpdate\n    }\n    if (this.props.componentDidUpdate) {\n      this.componentDidUpdate = this.props.componentDidUpdate\n    }\n    if (this.props.componentWillUnmount) {\n      this.componentWillUnmount = this.props.componentWillUnmount\n    }\n  }\n\n  /**\n   * Define getters and setters for state.\n   */\n  set state(data) {\n    const self = this\n    this[dataStore] = data\n    rAF(function() {\n      self.update()\n    })\n  }\n\n  get state() {\n    return this[dataStore]\n  }\n  \n  /**\n   * Method to set a component's state.\n   * @param {string|number|boolean|object|array} data The data to set.\n   * @param {number} [position] The index of an array whose data you want to set.\n   */\n  setState(data, position) {\n    if (typeof data === 'function') {\n      const state = data.call(this, this.state)\n      if (typeof state !== 'function' && !!state) this.setState(state)\n    }\n    if (Array.isArray(this.state)) {\n      const state = this.state\n      if (position || position === 0) {\n        if (typeof state[position] === 'object') {\n          mixin(state[position], data)\n          this.state = state\n        } else {\n          state[position] = data\n          this.state = state\n        }\n      } else {\n        this.state = state\n      }\n    } else if (typeof this.state === 'object') {\n      const state = this.state\n      mixin(state, data)\n      this.state = state\n    } else {\n      this.state = data\n    }\n  }\n\n  /**\n   * Function to render component after data changes.\n   * If data is passed as argument, it will be used.\n   * Otherwise state will be used.\n   * @param {boolean|number|string|object|array} [data ]\n   * @returns void\n   */\n  update(data) {\n    if (!this.render) return\n    const _data = data || this.state\n    if (this.componentWillUpdate) this.componentWillUpdate(this)\n    if (this.root && typeof this.root === 'string') {\n      this.selector = this.root\n      this.root = document.querySelector(this.root)\n    }\n\n    // Create virtual dom and check if component id alread exists in document.\n    const vdom = this.render(_data)\n    let elem\n    if (vdom && vdom.props && vdom.props.id) {\n      elem = this.root.querySelector(`#${vdom.props.id}`)\n    }\n\n    // If component element id already exists in DOM, \n    // remove it before rendering the component.\n    if (elem && !this.mounted) {\n      elem.parentNode.removeChild(elem)\n    }\n\n    // Patch DOM with component update.\n    this.element = patch(\n      this.oldNode,\n      (this.oldNode = this.render(_data)),\n      this.element,\n      this.root\n    )\n    if (!this.mounted) {\n      if (this.styles && (this.root && this.root.nodeName)) {\n        const styles = this.createComponentStyles()\n        if (typeof this.styles !== 'object') return\n        styles.css(this.selector, this.styles)\n      }\n      this.handleEvents()\n      this.componentWasCreated && this.componentWasCreated(this)\n      this.mounted = true\n    }\n    this.componentDidUpdate && this.componentDidUpdate(this)\n  }\n  \n  /**\n   * Method to destroy component.\n   * First unbind events.\n   * Then remove component element from DOM.\n   * Also null out component properties.\n   * @returns void\n   */\n  unmount() {\n    const self = this\n    this.componentWillUnmount && this.componentWillUnmount(this)\n    if (this.interactions && this.interactions.length) {\n      this.interactions.forEach(action => {\n        this.root.removeEvent(action.event, action.callback)\n      })\n    }\n    this.root.removeChild(this.element)\n    this.root = undefined\n    for (let key in this) {\n      delete this[key]\n    }\n    delete this.state\n    this.update = undefined\n    this.unmount = undefined\n  }\n}\n\n// Polyfill for Element.closest:\nif (window.Element && !Element.prototype.closest) {\n  Element.prototype.closest = \n  function(s) {\n    let matches = (this.document || this.ownerDocument).querySelectorAll(s)\n    let i\n    let el = this;\n    do {\n      i = matches.length;\n      while (--i >= 0 && matches.item(i) !== el) {};\n    } while ((i < 0) && (el = el.parentElement)); \n    return el;\n  };\n}\n","import {createElement} from './patch'\n\n/**\n * A function to create and inject a virtual node into the document. If a third, truthy parameter is provided, it will replace the contents of the root with the new element tree. Otherwise it will append the element. The first argument can be either a JSX tag or an h function.\n * \n * @param {function} tag A JSX tag or hyperscript function to render.\n * @param {Element|boolean} [root] The element into which the tag will be rendered.\n * @param {boolean} [replace] Whether to append to or replace the root content.\n */\nexport const injectElement = (tag, root, replace) => {\n  if (typeof root === 'string') root = document.querySelector(root)\n  if (!root || typeof root === 'boolean') {\n    replace = root\n    root = document.body\n  }\n  const element = createElement(tag)\n  if (replace) root.textContent = ''\n  root.append(element)\n}\n","/**\n * @type {object} subscriptions\n */\nconst subscriptions = {}\nconst hasProp = subscriptions.hasOwnProperty\n\n/**\n * Function to dispatch a topic and payload\n * @param {string} topic The topic to listen for.\n * @param {string|number|boolean|object|array} payload Any data to pass with the dispatch.\n */\nexport const dispatch = (topic, payload) => {\n  if (!hasProp.call(subscriptions, topic)) return\n  subscriptions[topic].map((item) => item(payload != undefined ? payload : {}))\n}\n\n/**\n * Function to subscribe to dispatches.\n * @param {string} topic The topic for the subscription.\n * @param {function} callback A function to execute when the dispatched topic matches.\n */\nexport const subscribe = (topic, callback) => {\n  if (!hasProp.call(subscriptions, topic)) subscriptions[topic] = []\n  const index = subscriptions[topic].push(callback) - 1\n}\n\n/**\n * Function to unsbuscribe from a topic.\n * @param {string} topic The topic to unsubscribe.\n */\nexport const unsubscribe = (topic) => delete subscriptions[topic]\n","/**\n * Hyperscript function. Enables definition of HTML/SVG using functions.\n * @param {string} type The name of the HTML or SVG tag to create.\n * @param {object} props And object of property/value pairs.\n * @param {string, number, boolean, any[]} children Any child elements.\n */\nexport function h(type, props, ...args) {\n  let stack = [], node\n  const children = []\n  stack = stack.concat(args.reverse())\n\n  while (stack.length) {\n    if (Array.isArray((node = stack.pop()))) {\n      node.map(item => stack.unshift(item))\n    } else if (node != null && node !== true && node !== false) {\n      typeof node === \"number\" ? node = node + '' : node\n      children.push(node)\n    }\n  }\n  \n  return typeof type === \"string\" \n    ? {type, props: props || {}, children } \n    : type(props, children)\n}\n","/**\n * Creates a universally unique identifier (uuid).\n * \n * @param {boolean} [param] Any truthy value. If true, uuid with have hyphens included.\n */\nexport const uuid = (param) => {\n  const numbers = param ? '' + 1e7 + -1e3 + -4e3 + -1e3 + -1e11 : '' + 1e7 + 1e3 + 4e3 + 8e3 + 1e11\n  let d = Date.now()\n  return (numbers).replace(/1|0/g, () => (0 | (d + Math.random() * 16) % 16).toString(16))\n}\n"],"names":["mixin","obj1","obj2","obj","keys","map","key","patch","oldNode","node","element","parent","diffAndPatch","document","body","setProps","name","value","oldValue","style","err","setAttribute","removeAttribute","createNode","svg","type","createElementNS","createElement","props","children","appendChild","child","createTextNode","getKey","updateElement","oldProps","nextSibling","insertBefore","len","length","oldLen","oldKeyed","oldElements","keyed","k","oldElement","childNodes","oldChild","oldKey","i","j","newChild","newKey","keyedNode","removeElement","nodeValue","data","removeChild","forEach","hasOwnProperty","p","defineProperty","rAF","window","requestAnimationFrame","webkitRequestAnimationFrame","mozRequestAnimationFrame","msRequestAnimationFrame","cb","setTimeout","dataStore","Date","getTime","Component","selector","this","root","render","state","styles","querySelector","scopedStylesheet","mounted","interactionsAreRegistered","createComponentStyles","flatten","array","flat","Array","prototype","concat","isArray","splice","createStyleSheet","options","prefix","unit","_sheet","_prefix","css","sharedSheet","createSheet","rules","rulesFromStyles","set","head","Error","id","Math","random","toString","slice","sheet","block","prop","isPlainObject","combineSelectors","push","insertRules","hyphenate","str","replace","$0","toLowerCase","rule","pairs","rulez","insertRule","join","pseudoRe","parents","split","part","separator","test","addUnit","isNaN","unitlessProps","Object","stylesheets","handleEvents","interactions","self","bubble","action","addEventListener","event","callback","e","els","call","querySelectorAll","target","closest","methods","method","componentWasCreated","componentWillUpdate","componentDidUpdate","componentWillUnmount","position","setState","babelHelpers.typeof","_data","vdom","elem","parentNode","nodeName","removeEvent","undefined","update","unmount","Element","s","matches","ownerDocument","el","item","parentElement","subscriptions","hasProp","stack","args","reverse","pop","unshift","tag","textContent","append","topic","payload","param","numbers","d","now"],"mappings":"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"}