{"version":3,"file":"composi.js","sources":["../lib/patch.js","../lib/component.js","../lib/h.js"],"sourcesContent":["/**\n * @constructor \n * @param {node} oldNode Original node or null.\n * @param {node} node New node.\n * @param {node} element The component root element.\n * @param {node} parent Parent node in which component is rendered.\n */\nexport function patch(oldNode, node, element, parent) {\n  element = diffAndPatch(parent || document.body, element, oldNode, node)\n  return element\n}\n/**\n * Patch functions:\n * merge\n * setProps \n * createNode\n * createElement\n * getKey\n * updateElement\n * removeElement\n * diffAndPatch\n */\n\n/**\n * Function to merge two objects.\n * @param {object} obj1 Target object.\n * @param {object} obj2 Object to merge into target.\n */\nconst merge = (obj1, obj2) => Object.assign({}, obj1, obj2)\n\n/**\n * Function to set properties and attributes on element.\n * @param {node} element \n * @param {string} name \n * @param {string|number|boolean} value \n * @param {string|number|boolean} oldValue \n */\nfunction setProps(element, name, value, oldValue) {\n  if (name === \"style\") {\n    for (let key of merge(oldValue, (value = value || {}))) {\n      element.style[key] = value[key] || ''\n    }\n  } else {\n    try {\n      element[name] = value\n    } catch (err) {}\n    typeof value !== \"function\" && value ? element.setAttribute(name, value) : element.removeAttribute(name)\n  }\n}\n\n/**\n * Function to create an HTML or SVG node.\n * @param {node} node node A node to create.\n * @param {svg} svg Whether the node is SVG or not.\n */\nfunction createNode(node, svg) {\n  const element = (svg = svg || node.type === \"svg\")\n  ? document.createElementNS(\"http://www.w3.org/2000/svg\", node.type)\n  : document.createElement(node.type)\n\n  for (let key in node.props) setProps(element, key, node.props[key])\n  node.children.map(child => element.appendChild(createElement(child, svg)))\n  return element\n}\n\n/**\n * Function to convert hyperscript/JSX into DOM nodes.\n * @param {jsx|hyperscript} node A node to create.\n * @param {svg} svg Whether the node is SVG or not.\n */\nexport function createElement(node, svg) {\n  let element\n  if (typeof node === \"string\") {\n    element = document.createTextNode(node)\n  } else {\n    element = createNode(node, svg)\n  }\n  return element\n}\n\n/**\n * Function to get a node's key.\n * @param {node} node \n */\nfunction getKey(node) {\n  if (node && (node = node.props)) {\n    return node.key\n  }\n}\n\n/**\n * Update an element with new values for properties and/or children.\n * @param {Element} element \n * @param {node} oldProps \n * @param {object} props \n */\nfunction updateElement(element, oldProps, props) {\n  for (let key in merge(oldProps, props)) {\n    let value = props[key]\n    , oldValue = key === \"value\" || key === \"checked\" ? element[key] : oldProps[key]\n\n    if (value !== oldValue) setProps(element, key, value, oldValue)\n  }\n}\n\n/**\n * Function to remove element from DOM.\n * @param {node} parent The parent of the element to remove.\n * @param {node} element The element to remove.\n */\nconst removeElement = (parent, element) => parent.removeChild(element)\n\n/**\n * Function to patch DOM. Diffs virtual nodes, then patches the DOM.\n * @param {node} parent \n * @param {node} element \n * @param {node} oldNode \n * @param {node} node \n * @param {boolean} svg \n * @param {node} nextSibling \n */\nfunction diffAndPatch(parent, element, oldNode, node, svg, nextSibling) {\n  if (oldNode == null) {\n    element = parent.insertBefore(createElement(node, svg), element)\n  } else if (node.type != null && node.type === oldNode.type) {\n    updateElement(element, oldNode.props, node.props)\n\n    svg = svg || node.type === \"svg\"\n    const len = node.children.length\n    , oldLen = oldNode.children.length\n    , oldKeyed = {}\n    , oldElements = []\n    , keyed = {}\n\n    let k = 0\n    while (k < oldLen) {\n      let oldElement = (oldElements[k] = element.childNodes[k])\n      , oldChild = oldNode.children[k]\n      , oldKey = getKey(oldChild)\n      if (null != oldKey) oldKeyed[oldKey] = [oldElement, oldChild]\n      k++\n    }\n\n    let i = 0\n    , j = 0\n\n    while (j < len) {\n      let oldElement = oldElements[i]\n      , oldChild = oldNode.children[i]\n      , newChild = node.children[j]\n      , oldKey = getKey(oldChild)\n  \n      if (keyed[oldKey]) {\n        i++\n        continue\n      }\n      \n      let newKey = getKey(newChild)\n      , keyedNode = oldKeyed[newKey] || []\n\n      if (null == newKey) {\n        if (null == oldKey) {\n          diffAndPatch(element, oldElement, oldChild, newChild, svg)\n          j++\n        }\n        i++\n      } else {\n        oldKey === newKey ? diffAndPatch(element, keyedNode[0], keyedNode[1], newChild, svg) && i++ :\n        keyedNode[0] ? element.insertBefore(keyedNode[0], oldElement) && diffAndPatch(element, keyedNode[0], keyedNode[1], newChild, svg) : diffAndPatch(element, oldElement, null, newChild, svg)\n        \n        keyed[newKey] = newChild\n\n        j++\n      }\n    }\n\n    while (i < oldLen) {\n      let oldChild = oldNode.children[i]\n      , oldKey = getKey(oldChild)\n      if (null == oldKey) removeElement(element, oldElements[i], oldChild.props)\n      i++\n    }\n\n    for (let key in oldKeyed) {\n      let keyedNode = oldKeyed[key]\n      , reusableNode = keyedNode[1]\n      if (!keyed[reusableNode.props.key]) {\n        removeElement(element, keyedNode[0], reusableNode.props)\n      }\n    }\n  } else if (element && node !== element.nodeValue) {\n    element = parent.insertBefore(\n      createElement(node, svg),\n      (nextSibling = element)\n    )\n    removeElement(parent, nextSibling, oldNode.props)\n  }\n  return element\n}\n","import {h} from './h'\nimport {patch} from './patch'\n\nvar rAF = window.requestAnimationFrame\n|| window.webkitRequestAnimationFrame\n|| window.mozRequestAnimationFrame\n|| window.msRequestAnimationFrame\n|| function(cb) { return setTimeout(cb, 16); };\n\n/**\n * A mixin function used for updating component state.\n * @param {object} obj1 An object as the target.\n * @param {object} obj2 An object of properties to target.\n */\nconst mixin = (obj1, obj2) => {\n  Object.keys(obj2).forEach(p => {\n    if (obj2.hasOwnProperty(p)) {\n      Object.defineProperty(obj1, p, {\n        value: obj2[p],\n        writable: true,\n        enumerable: false,\n        configurable: true\n      })\n    }\n  })\n}\n\n/**\n * @type {object} dataStore A pseudo-private property using Date object to store the component's state.\n */\nconst dataStore = Symbol ? Symbol() : new Date().getTime()\n\n/**\n * @type {function} noop A no operation function.\n */\nconst noop = () => {}\n\n/**\n * @class A class to create a component\n */\nexport class Component {\n  /**\n   * Constructor for Component class.\n   * @typedef {object} opts\n   * @property {string|element} root The root element in which to render the component.\n   * @property {?state} state The state object of the component. This can be of type boolean, string, number, object or array.\n   * @property {function} render A function that returns nodes to render to the DOM.\n   * @property {object} styles An object defining a component-scoped stylesheet.\n   * @property {object|array} interactions An object or array of objects defining user interactions. These are events with callbacks registed on the component or its child elements.\n   */\n  constructor(opts) {\n    this.selector = opts.element || opts.root || 'body'\n    if (opts.render) {\n      this.render = opts.render\n    }\n    this[dataStore] = opts.state\n    this.oldNode = null;\n    this.interactions = opts.interactions || []\n    this.styles = opts.styles\n    this.root = document.querySelector(this.selector)\n    this.scopedStylesheet = false\n    this.mounted = false\n    this.element\n    \n    /**\n     * Create virtual stylesheet for component.\n     */\n    this.createComponentStyles = function() {\n      let sharedSheet = null\n\n      const unitlessProps = {\n        columnCount: true,\n        fillOpacity: true,\n        flex: true,\n        flexGrow: true,\n        flexShrink: true,\n        fontWeight: true,\n        lineClamp: true,\n        lineHeight: true,\n        opacity: true,\n        order: true,\n        orphans: true,\n        widows: true,\n        zIndex: true,\n        zoom: true\n      }\n\n      function flatten(array) {\n        const flat = Array.prototype.concat(array)\n        for (let i = 0; i < flat.length; i++) {\n          if (Array.isArray(flat[i])) {\n            flat.splice(i, 1, flat[i--])\n          }\n        }\n        return flat\n      }\n\n      function createStyleSheet(options) {\n        if (!(this instanceof createStyleSheet)) {\n          return new createStyleSheet(options)\n        }\n        options || (options = {})\n        options.prefix = !options.hasOwnProperty(\"prefix\") ? true : !!options.prefix\n        options.unit = options.hasOwnProperty(\"unit\") ? options.unit : \"px\"\n\n        this._sheet = null\n        this._prefix = null\n\n        this.css = function (element, styles, selector) {\n          if (styles == null) return \"\"\n          if (this._sheet == null) {\n            this._sheet = sharedSheet = (sharedSheet || createSheet())\n          }\n          selector = element\n\n          const rules = rulesFromStyles(selector, styles)\n          if (options.prefix || options.unit !== \"\") {\n            rules.forEach(function(set) {\n              if (options.unit !== \"\") {\n                addUnit(set[1], options.unit)\n              }\n            })\n          }\n\n          insertRules(rules, this._sheet)\n        }\n      }\n\n      function createSheet() {\n        if (document.head == null) {\n          throw new Error(\"Can't add stylesheet before <head> is available. Make sure your document has a head element.\")\n        }\n        const style = document.createElement(\"style\")\n        style.id = \"styles_\" + Math.random().toString(16).slice(2, 8)\n        document.head.appendChild(style)\n        return style.sheet\n      }\n\n      function rulesFromStyles(selector, styles) {\n        if (!Array.isArray(styles)) styles = [styles]\n        const style = {}\n        let rules = []\n        styles = flatten(styles)\n        styles.forEach(function(block) {\n          for (let prop in block) {\n            let value = block[prop]\n            if (isPlainObject(value) || Array.isArray(value)) {\n              rules = rules.concat(\n                rulesFromStyles(combineSelectors(selector, prop), value)\n              )\n            } else {\n              if (prop === \"content\") value = \"'\"+value+\"'\"\n              style[prop] = value\n            }\n          }\n        })\n\n        rules.push([ selector, style ])\n        return rules\n      }\n\n      function insertRules(rules, sheet) {\n        window.sheet = sheet\n        function hyphenate(str) {\n          return str.replace(/[A-Z]/g, function($0) { return '-'+$0.toLowerCase() })\n        }\n        rules.forEach(function(rule) {\n          const pairs = []\n          for (let prop in rule[1]) {\n            pairs.push(hyphenate(prop) + \":\" + rule[1][prop])\n          }\n          if (pairs.length > 0) {\n            const rulez = rule[0] ? rule[0] : ''\n            sheet.insertRule(rulez + \"{\" + pairs.join(\";\") + \"}\", 0)\n          }\n        })\n      }\n\n      function combineSelectors(parent, child) {\n        const pseudoRe = /^[:\\[]/\n        const parents = parent.split(\",\"), children = child.split(\",\")\n        return parents.map(function(parent) {\n          return children.map(function(part) {\n            const separator = pseudoRe.test(part) ? \"\" : \" \"\n            return parent + separator + part\n          }).join(\",\")\n        }).join(\",\")\n      }\n\n      function addUnit(style, unit) {\n        for (let prop in style) {\n          let value = style[prop] + \"\"\n          if (!isNaN(value) && !unitlessProps[prop]) {\n            value = value + unit\n          }\n          style[prop] = value\n        }\n        return style\n      }\n\n      function isPlainObject(obj) {\n        return obj === Object(obj) && Object.prototype.toString === obj.toString\n      }\n\n      const stylesheets = {}\n      stylesheets.css = createStyleSheet().css\n      return stylesheets\n    }\n\n    /**\n     * Register events on the component or its child nodes.\n     */\n    this.handleEvents = function() {\n      if (!this.interactions) return\n      const self = this\n      let bubble = false\n      if (Array.isArray(this.interactions)) {\n        if (!this.interactions.length) return\n        this.interactions.forEach(function(action) {\n          bubble = action.bubble\n          if (action && action.element === 'self' || action && !action.element) {\n            self.root.addEventListener(action.event, action.callback, bubble)\n          } else {\n            self.root.addEventListener(action.event, function(e) {\n              let target = e.target\n              if (e.target.nodeType === 3) {\n                target = e.target.parentNode\n              }\n              const els = [].slice.call(self.root.querySelectorAll(action.element))\n              els.forEach(el => {\n                if (el === target) {\n                  action.callback.call(el, e)\n                } else {\n                  try {\n                     const ancestor = target.closest(action.element)\n                     if (delegateElement === ancestor.array[0]) {\n                     }\n                  } catch(err) {}\n                }\n              })\n            })\n          }\n        })\n      }\n    }\n    \n    /**\n     * Check for interactions.\n     */\n    if (opts.interactions) {\n      this.interactions = opts.interactions || []\n    }\n    if (this.interactions) {\n      this.handleEvents()\n    }\n\n    /**\n     * Attach any functions provided in methods property as component methods.\n     */\n    if (opts.methods) {\n      const self = this\n      for (let method in opts.methods) {\n        self[method] = opts.methods[method]\n      }\n    }\n    \n    /**\n     * Handle lifecycle methods.\n     */\n    if (opts.componentWasCreated) {\n      this.componentWasCreated = opts.componentWasCreated\n    }\n    if (opts.componentWillUpdate) {\n      this.componentWillUpdate = opts.componentWillUpdate\n    }\n    if (opts.componentDidUpdate) {\n      this.componentDidUpdate = opts.componentDidUpdate\n    }\n    if (opts.componentWillUnmount) {\n      this.componentWillUnmount = opts.componentWillUnmount\n    }\n  }\n\n  /**\n   * Define getters and setters for state.\n   */\n  set state(data) {\n    const self = this\n    this[dataStore] = data\n    rAF(function() {\n      self.update()\n    })\n  }\n\n  get state() {\n    return this[dataStore]\n  }\n  \n  /**\n   * Method to set a component's state.\n   * @param {string|number|boolean|object|array} data The data to set.\n   * @param {?number} position The index of an array whose data you want to set.\n   */\n  setState(data, position) {\n    if (Array.isArray(this.state)) {\n      const state = this.state\n      if (position || position === 0) {\n        if (typeof state[position] === 'object') {\n          mixin(state[position], data)\n          this.state = state\n        } else {\n          state[position] = data\n          this.state = state\n        }\n      } else {\n        this.state = state\n      }\n    } else if (typeof this.state === 'object') {\n      const state = this.state\n      mixin(state, data)\n      this.state = state\n    } else {\n      this.state = data\n    }\n  }\n\n  /**\n   * Function to render component after data changes.\n   * If data is passed as argument, it will be used.\n   * Otherwise state will be used.\n   * @param {?boolean|number|string|object|array} data \n   * @returns void\n   */\n  update(data) {\n    if (!this.render) return\n    const _data = data || this.state\n    if (this.componentWillUpdate) this.componentWillUpdate(this)\n    const domUpdate =  (this.element = patch(\n      this.oldNode,\n      (this.oldNode = this.render(_data)),\n      this.element,\n      this.root\n    ))\n    if (!this.mounted) {\n      if (this.styles && (this.root && this.root.nodeName)) {\n        const styles = this.createComponentStyles()\n        if (typeof this.styles !== 'object') return\n        styles.css(this.selector, this.styles)\n      }\n      if (this.componentWasCreated) this.componentWasCreated(this)\n      this.mounted = true\n    }\n    if (this.componentDidUpdate) this.componentDidUpdate(this)\n  }\n  \n  /**\n   * Method to destroy component.\n   * First unbind events.\n   * Then remove component element from DOM.\n   * Also null out component properties.\n   * @returns void\n   */\n  unmount() {\n    const self = this\n    if (this.componentWillUnmount) this.componentWillUnmount(this)\n    this.interactions.forEach(action => {\n      this.root.removeEvent(action.event, action.callback)\n    })\n    this.root.removeChild(this.element)\n    this.root = undefined\n    for (let key in this) {\n      delete this[key]\n    }\n    delete this.state\n    this.update = undefined\n    this.unmount = undefined\n  }\n}\n\n/**\n * Polyfill for Element.closest.\n * Used by handleEvents function for delegating events.\n */\nif (window.Element && !Element.prototype.closest) {\n  Element.prototype.closest = \n  function(s) {\n    let matches = (this.document || this.ownerDocument).querySelectorAll(s)\n    let i\n    let el = this;\n    do {\n      i = matches.length;\n      while (--i >= 0 && matches.item(i) !== el) {};\n    } while ((i < 0) && (el = el.parentElement)); \n    return el;\n  };\n}\n","/**\n * Hyperscript function. Enables definition of HTML/SVG using functions.\n * @param {string} type The name of the HTML or SVG tag to create.\n * @param {object} props And object of property/value pairs.\n * @param {string, number, boolean, any[]} children Any child elements.\n */\nexport function h(type, props, ...args) {\n  let stack = [], node\n  const children = []\n  stack = stack.concat(args.reverse())\n\n  while (stack.length) {\n    if (Array.isArray((node = stack.pop()))) {\n      node.map(item => stack.unshift(item))\n    } else if (node != null && node !== true && node !== false) {\n      typeof node === \"number\" ? node = node + '' : node\n      children.push(node)\n    }\n  }\n  \n  return typeof type === \"string\" \n    ? {type, props: props || {}, children } \n    : type(props, children)\n}\n"],"names":["patch","oldNode","node","element","parent","diffAndPatch","document","body","setProps","name","value","oldValue","merge","key","style","err","setAttribute","removeAttribute","createNode","svg","type","createElementNS","createElement","props","children","map","appendChild","child","createTextNode","getKey","updateElement","oldProps","nextSibling","insertBefore","len","length","oldLen","oldKeyed","oldElements","keyed","k","oldElement","childNodes","oldChild","oldKey","i","j","newChild","newKey","keyedNode","removeElement","reusableNode","nodeValue","obj1","obj2","Object","assign","removeChild","rAF","window","requestAnimationFrame","webkitRequestAnimationFrame","mozRequestAnimationFrame","msRequestAnimationFrame","cb","setTimeout","mixin","keys","forEach","hasOwnProperty","p","defineProperty","dataStore","Symbol","Date","getTime","Component","opts","selector","root","render","state","interactions","styles","querySelector","this","scopedStylesheet","mounted","createComponentStyles","flatten","array","flat","Array","prototype","concat","isArray","splice","createStyleSheet","options","prefix","unit","_sheet","_prefix","css","sharedSheet","createSheet","rules","rulesFromStyles","set","head","Error","id","Math","random","toString","slice","sheet","block","prop","isPlainObject","combineSelectors","push","insertRules","hyphenate","str","replace","$0","toLowerCase","rule","pairs","rulez","insertRule","join","pseudoRe","parents","split","part","separator","test","addUnit","isNaN","unitlessProps","obj","stylesheets","handleEvents","self","bubble","action","addEventListener","event","callback","e","target","nodeType","parentNode","call","querySelectorAll","el","closest","methods","method","componentWasCreated","componentWillUpdate","componentDidUpdate","componentWillUnmount","data","position","babelHelpers.typeof","_data","nodeName","removeEvent","undefined","update","unmount","Element","s","matches","ownerDocument","item","parentElement","stack","args","reverse","pop","unshift"],"mappings":"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"}